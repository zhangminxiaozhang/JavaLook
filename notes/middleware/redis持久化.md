Redis的数据全部存在内存中，这个时候如果Redis突然宕机了，那么数据就会丢失，因此需要利用Redis的持久化机制。

### 一、持久化类型

- #### rdb快照

全量进行备份，即在某个时间点讲Redis中存储的所有数据全部备份到磁盘上。

- #### AOF日志

连续增量备份，通过记录Redis的指令，然后定时备份到磁盘上，有时候AOF日志运行就会无比庞大，因此可以通过对AOF日志重写来降低数据库重启时加载AOF的时间。

### 二、rdb快照原理

Redis是单线程程序，如果让这个线程不仅负责多个客户端套接字的并发读写操作和内存数据结构的逻辑读写操作，还让它进行IO操作进行快照存储，是在有点强人所难。

Redis使用的是多线程COW机制实现快照持久化。即持久化过程中通过fork一个子进程，然后快照持久化的操作完全交给子进程去做，父进程仍然处理客户端的请求，这个时候父子进程共享内存里面的代码和数据段。

当子进程在做数据持久化的过程中，它不会修改内存中的数据结构，只是进行读取然后序列化到磁盘中。但是父进程还要接受客户端的请求，并且对内存数据结构不断的修改，那么一旦父进程对内存的数据结构进行了修改，这块本来由二者共享的页面也就会复制一份，父进程就会在这个复制出来的页面上进行修改，子进程看到的还是之前没有修改过的页面，也就是持久化的磁盘数据是子进程产生的那一刻所有数据，也就是被称之为“快照”

### 三、AOF原理

AOF日志存储的是Redis服务器的顺序指令序列且是那些**对内存进行修改的指令记录**

为了对AOF日志进行瘦身，Redis的bgrewriteaof指令通过开辟一个子进程对内存进行遍历转化成Redis操作指令，之后序列化到新的AOF日志文件中，序列化完成之后再将操作期间发生的增量AOF日志进行追加，追加完毕之后替代旧的AOF日志。

为了避免机器突然宕机，AOF日志还没有刷到磁盘中，可以通过fsync函数来决定多长时间进行一次刷盘操作，一般每隔1s

### 四、混合持久化

由于rdb存储是全量数据，因此一般不用rdb恢复内存，因为如果在持久化的过程中宕机就会丢失很多数据，AOF在宕机的时候丢失的数据较少，但是AOF由于日志重放的时间很长，在启动的时候会耗费很长时间。

将rdb文件内容和增量的AOF日志文件存在一起，这里面的AOF日志存储的是rdb持久化开始到结束的这段时间的增量AOF日志，通常这部分很少。

可以在重启的时候，先加载rdb内容，然后再重放增量AOF日志，这样重启的效率就会大大提升。

<div align="center">  <img src="https://i.bmp.ovh/imgs/2021/06/e37816ee40391d54.png" width="500"/> </div><br>

