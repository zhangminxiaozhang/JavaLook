### 由来

单机场景中，多线程之间可以通过synchronized和lock锁来实现线程安全。在分布式应用场景中，如果同时对同一个状态值进行修改，不加分布式锁的话，也会发生并发问题，虽然分布式锁的解决方案有很多中，接下来将简单一下由Redis实现分布式锁的原理。

<div align="center">  <img src="https://ftp.bmp.ovh/imgs/2021/05/833c093f8ad6497b.png" width="600"/> </div><br>

### 解决思路

#### 思路1

可以利用setnx让一个应用去占据坑位，等待业务完成之后del去释放这个坑位，这个时候其他应用来的时候由于唯一的一个坑位被占据了，放弃或者继续等待[取决于业务]。

```
>setnx lock true  #这里面的value其实取任意值都是可以的
 进行业务，等待完成
>del lock
```

#### 问题

上述逻辑上不存在问题，但如果业务一直结束不了或者业务中途宕机了，就会导致无法执行del lock，那么其他的应用也就无法进行后续操作了，即死锁了。



#### 思路2

我们应用在获得锁的同时，也会给这个锁加上一个过期时间，这样哪怕获得锁的应用出现了问题，锁也会正常释放的。

```
>setnx lock true 
>expire lock 50 #50s之后锁过期
 进行业务，等待完成
>del lock
```

#### 问题

加上过期时间很好，但是由于这两条指令不是原子性操作，如果应用在获得锁之后就挂掉了，还没等expire操作，那么陷入的问题同上。



#### 思路3

归结于上述思路2问题，可以整合上述两个的一条原子性指令。`\> set lock true ex 50 nx`

#### 问题

如果应用1在获得锁之后，执行的业务时间过长，那么在等待50s之后，锁就会自动被删除了，那么应用2就会抢到锁，去执行业务的过程中，应用1已经把业务执行完成了，它不知道锁实际上已经被释放了，仍然去删除锁，结果把应用2辛苦获得的锁给删掉了，那么应用3一看锁没了，也可以趁虚而入执行它的业务过程，于是乎出现了并发问题。



#### 思路4

上述思路3的问题出现原因在于应用1仍然去删除了锁，如果它已经知道锁没了，那么它就不会甚至没有锁给它删除，于是可以设置锁的value是一个随机值比如时间，每次去del的时候都会去比较一下。

伪代码如下：

```
tag = random.nextint() # 随机数
if redis.set(key, tag, nx=True, ex=5):
do_something()
redis.delifequals(key, tag) # 假象的 delifequals 指令
```

借助Lua脚本可以实现多个指令原子执行

```lua
# delifequals
if redis.call("get",KEYS[1]) == ARGV[1] then
		return redis.call("del",KEYS[1])
else return 0
end
```



以上是我对Redis实现分布式锁的一点理解。



